// Generated by LiveScript 1.2.0
(function(){
  var mod, Throttler, ScrollHandler;
  mod = angular.module('infinite-scroll', []);
  mod.value('THROTTLE_MILLISECONDS', null);
  Throttler = require('./throttler');
  ScrollHandler = require('./scroll-handler');
  mod.directive('infiniteScroller', [
    '$rootScope', '$window', '$timeout', 'THROTTLE_MILLISECONDS', function($rootScope, $window, $timeout, THROTTLE_MILLISECONDS){
      var handleInfiniteScrollDistance;
      ({
        scope: {
          infiniteScroll: '&',
          debugOn: '&',
          infiniteScrollContainer: '=',
          infiniteScrollDistance: '=',
          infiniteScrollDisabled: '='
        },
        debugMsg: function(){
          if (this.debugOn) {
            return console.log.apply(this, arguments);
          }
        },
        config: new ScrollConfig,
        handleInfiniteScrollDisabled: function(value){
          this.configToggleScrollEnabled(value);
          if (this.config.isScrollEnabled()) {
            this.config.disableScroll();
            return this.handler();
          }
        },
        handleInfiniteScrollContainer: function(newContainer){
          if (!this.isValidContainer(newContainer)) {
            return;
          }
          return this.changeContainer(newContainer);
        },
        isValidContainer: function(container){
          return container != null && container.length > 0;
        },
        changeContainer: function(newContainer){
          newContainer = this.wrapAngular(newContainer);
          if (this.container != null) {
            this.container.off('scroll', handler);
          }
          this.container = newContainer;
          return this.container.on('scroll', handler);
        }
      });
      handleInfiniteScrollDistance = function(value){
        return this.config.setScrollDistance(value);
      };
      return {
        wrapAngular: function(element){
          return angular.element(element);
        },
        throttler: function(debug){
          return this._throttler || (this._throttler = new Throttler($timeout, debug));
        },
        basicScrollHandler: function(debug){
          return new ScrollHandler(debug).handleScroll;
        },
        throttledScrollHandler: function(waitMs, debug){
          if (waitMs != null) {
            return this.throttler(debug).config(this.scrollHandler(debug), waitMs);
          }
        },
        createScrollHandler: function(wait, debug){
          return this.scrollHandler = this.throttledScrollHandler(wait, debug) || this.basicHandler(debug);
        },
        link: function(scope, elem, attrs){
          var $window, waitMs, parent, angleParent, self;
          debugMsg("infiniteScroller: link ", attrs);
          $window = this.wrapAngular($window);
          this.debugOn = attrs.debugOn;
          this.debugLv = attrs.debugLv || 0;
          waitMs = THROTTLE_MILLISECONDS;
          debugMsg("wait ", waitMs);
          this.createScrollHandler(waitMs, this.debugLv);
          scope.$on('$destroy', function(){
            return this.config.container.off('scroll', this.scrollHandler);
          });
          debugMsg("infiniteScrollDistance", this.handleInfiniteScrollDistance);
          scope.$watch('infiniteScrollDistance', this.handleInfiniteScrollDistance);
          this.handleInfiniteScrollDistance(scope.infiniteScrollDistance);
          debugMsg("handle-infinite-scroll-distance using", scope.infiniteScrollDistance);
          scope.$watch('infiniteScrollDisabled', handleInfiniteScrollDisabled);
          handleInfiniteScrollDisabled(scope.infiniteScrollDisabled);
          debugMsg("try changing container to $window");
          this.changeContainer($window);
          scope.$watch('infiniteScrollContainer', handleInfiniteScrollContainer);
          this.handleInfiniteScrollContainer(scope.infiniteScrollContainer) || [];
          if (attrs.infiniteScrollParent != null) {
            parent = elem.parent();
            angleParent = this.wrapAngular(parent);
            this.debugMsg("Infinite scroll parent is", angleParent);
            this.changeContainer(angleParent);
          } else {
            this.debugMsg("Infinite scroll parent is window");
          }
          if (attrs.infiniteScrollImmediateCheck != null) {
            this.debugMsg("infinite-scroll-immediate-check", attrs.infiniteScrollImmediatecheck);
            this.config.immediateCheck = scope.$eval(attrs.infiniteScrollImmediatecheck);
          }
          self = this;
          return $timeout(function(){
            self.debugMsg('timeout');
            if (self.immediateCheck) {
              self.debugMsg('immediate check OK - run handler!');
              return self.scrollHandler.handleScroll();
            }
          }, 0);
        }
      };
    }
  ]);
}).call(this);
