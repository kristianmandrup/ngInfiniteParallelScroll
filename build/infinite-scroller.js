(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var navigatorHelper, BaseContainerConfig, WindowContainerConfig, DomContainerConfig;
  navigatorHelper = require('./navigator');
  BaseContainerConfig = (function(){
    BaseContainerConfig.displayName = 'BaseContainerConfig';
    var prototype = BaseContainerConfig.prototype, constructor = BaseContainerConfig;
    importAll$(prototype, arguments[0]);
    function BaseContainerConfig(scrollConfig){
      this.scrollConfig = scrollConfig;
      this.log();
      this.configure();
    }
    prototype.log = function(){
      return debug("container configuration");
    };
    prototype.containerBottom = function(){
      return this._containerBottom = calcContainerBottom();
    };
    prototype.elemBottom = function(){
      return this._elementBottom = calcElemBottom();
    };
    prototype.scrollBoundary = function(){
      return this.cHeight() * this.config.scrollDistance + 1;
    };
    prototype.cHeight = function(){
      return this.container.height();
    };
    prototype.eHeight = function(){
      return this.elem.height();
    };
    prototype.configure = function(){
      var ref$;
      return ref$ = this.scrollConfig, this.config = ref$.config, this.container = ref$.container, this.elem = ref$.elem, this.debugging = ref$.debugging, ref$;
    };
    prototype.isChromeBrowser = function(){
      return this.browserName() === 'Chrome';
    };
    prototype.browserName = function(){
      return navigatorHelper.sayswho.match(/\w+/)[0];
    };
    prototype.browserVersion = function(){
      return parseInt(navigatorHelper.sayswho.match(/\d+/)[0], 10);
    };
    return BaseContainerConfig;
  }(Debugger));
  WindowContainerConfig = (function(superclass){
    var prototype = extend$((import$(WindowContainerConfig, superclass).displayName = 'WindowContainerConfig', WindowContainerConfig), superclass).prototype, constructor = WindowContainerConfig;
    function WindowContainerConfig(container, elem, debugging){
      this.container = container;
      this.elem = elem;
      this.debugging = debugging;
      WindowContainerConfig.superclass.apply(this, arguments);
    }
    prototype.calcContainerBottom = function(){
      return this.container.height() + this.container.scrollTop();
    };
    prototype.calcElemBottom = function(){
      return this.elem.offset().top + this.eHeight();
    };
    prototype.configure = function(){
      return superclass.prototype.configure.call(this);
    };
    prototype.configureForChrome = function(){
      return this.cHeight = function(){
        return this.container.innerHeight();
      };
    };
    return WindowContainerConfig;
  }(BaseContainerConfig));
  DomContainerConfig = (function(superclass){
    var prototype = extend$((import$(DomContainerConfig, superclass).displayName = 'DomContainerConfig', DomContainerConfig), superclass).prototype, constructor = DomContainerConfig;
    function DomContainerConfig(config){
      this.config = config;
      DomContainerConfig.superclass.apply(this, arguments);
    }
    prototype.configure = function(){
      return superclass.prototype.configure.call(this);
    };
    prototype.calcContainerBottom = function(){
      return this.cHeight();
    };
    prototype.calcElemBottom = function(){
      return this.elem.offset().top - this.container.offset().top + this.eHeight();
    };
    return DomContainerConfig;
  }(BaseContainerConfig));
  module.exports = {
    BaseContainerConfig: BaseContainerConfig,
    WindowContainerConfig: WindowContainerConfig,
    DomContainerConfig: DomContainerConfig
  };
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);

},{"./navigator":4}],2:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  module.exports = {
    debugging: false,
    hasDebug: function(){
      return this.debugging || constructor.debugAll;
    },
    debug: function(){
      var constr;
      if (this.hasDebug()) {
        constr = this.constructor.displayName || this.displayName;
        console.log(constr + ':');
        return console.log.apply(this, arguments);
      }
    },
    debugLv: 0,
    infoMsg: function(){
      if (this.hasDebug() && this.debugLv > 0) {
        return console.log.apply(this, arguments);
      }
    },
    debugAllOn: function(){
      return this.debugAll = true;
    },
    debugAllOff: function(){
      return this.debugAll = false;
    },
    debugOn: function(){
      return this.debugging = true;
    },
    debugOff: function(){
      return this.debugging = false;
    }
  };
}).call(this);

},{}],3:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var mod, Throttler, ScrollHandler;
  mod = angular.module('infinite-scroll', []);
  mod.value('THROTTLE_MILLISECONDS', null);
  Throttler = require('./throttler');
  ScrollHandler = require('./scroll-handler');
  mod.directive('infiniteScroller', [
    '$rootScope', '$window', '$timeout', 'THROTTLE_MILLISECONDS', function($rootScope, $window, $timeout, THROTTLE_MILLISECONDS){
      var handleInfiniteScrollDistance;
      ({
        scope: {
          infiniteScroll: '&',
          debugOn: '&',
          debugLv: '&',
          infiniteScrollContainer: '=',
          infiniteScrollDistance: '=',
          infiniteScrollDisabled: '='
        },
        debugMsg: function(){
          if (this.debugOn) {
            return console.log.apply(this, arguments);
          }
        },
        config: new ScrollConfig,
        handleInfiniteScrollDisabled: function(value){
          this.configToggleScrollEnabled(value);
          if (this.config.isScrollEnabled()) {
            this.config.disableScroll();
            return this.handler();
          }
        },
        handleInfiniteScrollContainer: function(newContainer){
          if (!this.isValidContainer(newContainer)) {
            return;
          }
          return this.changeContainer(newContainer);
        },
        isValidContainer: function(container){
          return container != null && container.length > 0;
        },
        changeContainer: function(newContainer){
          newContainer = this.wrapAngular(newContainer);
          if (this.container != null) {
            this.container.off('scroll', handler);
          }
          this.container = newContainer;
          return this.container.on('scroll', handler);
        }
      });
      handleInfiniteScrollDistance = function(value){
        return this.config.setScrollDistance(value);
      };
      return {
        wrapAngular: function(element){
          return angular.element(element);
        },
        throttler: function(debug){
          return this._throttler || (this._throttler = new Throttler($timeout, debug));
        },
        basicScrollHandler: function(debug){
          return new ScrollHandler(debug).handleScroll;
        },
        throttledScrollHandler: function(waitMs, debug){
          if (waitMs != null) {
            return this.throttler(debug).config(this.scrollHandler(debug), waitMs);
          }
        },
        createScrollHandler: function(wait, debug){
          return this.scrollHandler = this.throttledScrollHandler(wait, debug) || this.basicHandler(debug);
        },
        link: function(scope, elem, attrs){
          var $window, waitMs, parent, angleParent, self;
          debugMsg("infiniteScroller: link ", attrs);
          $window = this.wrapAngular($window);
          this.debugOn = attrs.debugOn;
          this.debugLv = attrs.debugLv || 0;
          waitMs = THROTTLE_MILLISECONDS;
          debugMsg("wait ", waitMs);
          this.createScrollHandler(waitMs, this.debugLv);
          scope.$on('$destroy', function(){
            return this.config.container.off('scroll', this.scrollHandler);
          });
          debugMsg("infiniteScrollDistance", this.handleInfiniteScrollDistance);
          scope.$watch('infiniteScrollDistance', this.handleInfiniteScrollDistance);
          this.handleInfiniteScrollDistance(scope.infiniteScrollDistance);
          debugMsg("handle-infinite-scroll-distance using", scope.infiniteScrollDistance);
          scope.$watch('infiniteScrollDisabled', handleInfiniteScrollDisabled);
          handleInfiniteScrollDisabled(scope.infiniteScrollDisabled);
          debugMsg("try changing container to $window");
          this.changeContainer($window);
          scope.$watch('infiniteScrollContainer', handleInfiniteScrollContainer);
          this.handleInfiniteScrollContainer(scope.infiniteScrollContainer) || [];
          if (attrs.infiniteScrollParent != null) {
            parent = elem.parent();
            angleParent = this.wrapAngular(parent);
            this.debugMsg("Infinite scroll parent is", angleParent);
            this.changeContainer(angleParent);
          } else {
            this.debugMsg("Infinite scroll parent is window");
          }
          if (attrs.infiniteScrollImmediateCheck != null) {
            this.debugMsg("infinite-scroll-immediate-check", attrs.infiniteScrollImmediatecheck);
            this.config.immediateCheck = scope.$eval(attrs.infiniteScrollImmediatecheck);
          }
          self = this;
          return $timeout(function(){
            self.debugMsg('timeout');
            if (self.immediateCheck) {
              self.debugMsg('immediate check OK - run handler!');
              return self.scrollHandler.handleScroll();
            }
          }, 0);
        }
      };
    }
  ]);
}).call(this);

},{"./scroll-handler":5,"./throttler":6}],4:[function(require,module,exports){
navigator.sayswho = (function(){
    var ua= navigator.userAgent, tem,
        M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if(/trident/i.test(M[1])){
        tem=  /\brv[ :]+(\d+)/g.exec(ua) || [];
        return 'IE '+(tem[1] || '');
    }
    if(M[1]=== 'Chrome'){
        tem= ua.match(/\bOPR\/(\d+)/)
        if(tem!= null) return 'Opera '+tem[1];
    }
    M= M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
    if((tem= ua.match(/version\/(\d+)/i))!= null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();
},{}],5:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var Debugger, containerConfigs, ScrollHandler;
  Debugger = require('./debugger');
  containerConfigs = require('./container-configs');
  ScrollHandler = (function(){
    ScrollHandler.displayName = 'ScrollHandler';
    var prototype = ScrollHandler.prototype, constructor = ScrollHandler;
    importAll$(prototype, arguments[0]);
    function ScrollHandler(scope, config, debug){
      this.scope = scope;
      this.config = config;
      this.container = this.config.container;
      this.elem = this.config.elem;
      this.scrollDistance = this.config.scrollDistance;
      this.scrollEnabled = this.config.scrollEnabled;
      if (debug != null) {
        this.debugOn();
      }
      this.debugLv = parseInt(debug, 10) || 0;
      this;
    }
    prototype.handleScroll = function(){
      infoMsg("remaining", this.remaining());
      infoMsg("scroll-boundary", this.scrollBoundary());
      debug("handle scroll, should:", this.shouldScroll());
      if (this.shouldScroll()) {
        return this.scroll();
      }
    };
    prototype.isWindowContainer = function(){
      return this.container === $window;
    };
    prototype.scroll = function(){
      infoMsg("scroll");
      if (this.scrollEnabled) {
        return this.performScroll();
      } else {
        return this.enableScroll();
      }
    };
    prototype.performScroll = function(){
      infoMsg("perform scroll");
      this.configureScroll();
      return this.scope.infiniteScroll();
    };
    prototype.enableScroll = function(){
      infoMsg("enable scroll", this.config);
      return this.config.enableScroll();
    };
    prototype.configureScroll = function(){
      return infoMsg("configure-scroll, window-container:", this.isWindowContainer());
    };
    prototype.shouldScroll = function(){
      return this.remaining() <= this.scrollBoundary();
    };
    prototype.scrollBoundary = function(){
      return this.containerConfig().scrollBoundary();
    };
    prototype.remaining = function(){
      return this._remaining || (this._remaining = this.elementBottom() - this.containerBottom());
    };
    prototype.elementBottom = function(){
      return this.containerConfig().elementBottom();
    };
    prototype.containerBottom = function(){
      return this.containerConfig().containerBottom();
    };
    prototype.containerConfig = function(){
      return this._containerConfig || (this._containerConfig = this.windowContainerConfig() || this.domContainerConfig());
    };
    prototype.domContainerConfig = function(){
      return new containerConfigs.ContainerConfig(this.scrollConfigObj());
    };
    prototype.scrollConfigObj = function(){
      return {
        config: this.config,
        container: this.container,
        elem: this.elem,
        debug: this.debugging
      };
    };
    prototype.windowContainerConfig = function(){
      if (this.isWindowContainer()) {
        return this._windowContainerConfig || (this._windowContainerConfig = new containerConfigs.WindowContainerConfig(this.scrollConfigObj()));
      }
    };
    return ScrollHandler;
  }(Debugger));
  module.exports = ScrollHandler;
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);

},{"./container-configs":1,"./debugger":2}],6:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var Debugger, Throttler;
  Debugger = require('./debugger');
  Throttler = (function(){
    Throttler.displayName = 'Throttler';
    var prototype = Throttler.prototype, constructor = Throttler;
    importAll$(prototype, arguments[0]);
    function Throttler($timeout){
      this.$timeout = $timeout;
    }
    prototype.config = function(func, wait){
      this.func = func;
      this.wait = wait;
      return this.throttle;
    };
    prototype.throttle = function(){
      if (this.noTimeRemaining()) {
        return this.reset();
      } else {
        return this.setTimeout();
      }
    };
    prototype.noTimeRemaining = function(){
      return this.remainingTime() <= 0;
    };
    prototype.remainingTime = function(){
      return this.remaining || (this.remaining = wait - (this.now() - this.previous));
    };
    prototype.setTimeout = function(){
      debug("set timeout");
      return this.timeout || (this.timeout = $timeout(later, remaining));
    };
    prototype.reset = function(){
      debug("reset");
      this.clearTimeout(this.timeout);
      this.$timeout.cancel(this.timeout);
      this.timeout = null;
      this.previous = this.now();
      return this.func.call();
    };
    prototype.now = function(){
      return this._now || (this._now = new Date().getTime());
    };
    prototype.timeout = null;
    prototype.previous = 0;
    prototype.later = function(){
      debug("later");
      this.previous = new Date().getTime();
      this.$timeout.cancel(timeout);
      this.timeout = null;
      this.func.call();
      return this.context = null;
    };
    return Throttler;
  }(Debugger));
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);

},{"./debugger":2}]},{},[3])