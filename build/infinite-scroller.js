(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  module.exports = {
    debugging: false,
    hasDebug: function(){
      return this.debugging || constructor.debugAll;
    },
    debug: function(){
      var constr;
      if (this.hasDebug()) {
        constr = this.constructor.displayName || this.displayName;
        console.log(constr + ':');
        return console.log.apply(this, arguments);
      }
    },
    debugLv: 0,
    infoMsg: function(){
      if (this.hasDebug() && this.debugLv > 0) {
        return console.log.apply(this, arguments);
      }
    },
    debugAllOn: function(){
      return this.debugAll = true;
    },
    debugAllOff: function(){
      return this.debugAll = false;
    },
    debugOn: function(){
      return this.debugging = true;
    },
    debugOff: function(){
      return this.debugging = false;
    }
  };
}).call(this);

},{}],2:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var mod, Throttler, ScrollHandler;
  mod = angular.module('infinite-scroll', []);
  mod.value('THROTTLE_MILLISECONDS', null);
  Throttler = require('./throttler');
  ScrollHandler = require('./scroll-handler');
  mod.directive('infiniteScroller', [
    '$rootScope', '$window', '$timeout', 'THROTTLE_MILLISECONDS', function($rootScope, $window, $timeout, THROTTLE_MILLISECONDS){
      var handleInfiniteScrollDistance;
      ({
        scope: {
          infiniteScroll: '&',
          debugOn: '&',
          infiniteScrollContainer: '=',
          infiniteScrollDistance: '=',
          infiniteScrollDisabled: '='
        },
        debugMsg: function(){
          if (this.debugOn) {
            return console.log.apply(this, arguments);
          }
        },
        config: new ScrollConfig,
        handleInfiniteScrollDisabled: function(value){
          this.configToggleScrollEnabled(value);
          if (this.config.isScrollEnabled()) {
            this.config.disableScroll();
            return this.handler();
          }
        },
        handleInfiniteScrollContainer: function(newContainer){
          if (!this.isValidContainer(newContainer)) {
            return;
          }
          return this.changeContainer(newContainer);
        },
        isValidContainer: function(container){
          return container != null && container.length > 0;
        },
        changeContainer: function(newContainer){
          newContainer = this.wrapAngular(newContainer);
          if (this.container != null) {
            this.container.off('scroll', handler);
          }
          this.container = newContainer;
          return this.container.on('scroll', handler);
        }
      });
      handleInfiniteScrollDistance = function(value){
        return this.config.setScrollDistance(value);
      };
      return {
        wrapAngular: function(element){
          return angular.element(element);
        },
        throttler: function(debug){
          return this._throttler || (this._throttler = new Throttler($timeout, debug));
        },
        basicScrollHandler: function(debug){
          return new ScrollHandler(debug).handleScroll;
        },
        throttledScrollHandler: function(waitMs, debug){
          if (waitMs != null) {
            return this.throttler(debug).config(this.scrollHandler(debug), waitMs);
          }
        },
        createScrollHandler: function(wait, debug){
          return this.scrollHandler = this.throttledScrollHandler(wait, debug) || this.basicHandler(debug);
        },
        link: function(scope, elem, attrs){
          var $window, waitMs, parent, angleParent, self;
          debugMsg("infiniteScroller: link ", attrs);
          $window = this.wrapAngular($window);
          this.debugOn = attrs.debugOn;
          this.debugLv = attrs.debugLv || 0;
          waitMs = THROTTLE_MILLISECONDS;
          debugMsg("wait ", waitMs);
          this.createScrollHandler(waitMs, this.debugLv);
          scope.$on('$destroy', function(){
            return this.config.container.off('scroll', this.scrollHandler);
          });
          debugMsg("infiniteScrollDistance", this.handleInfiniteScrollDistance);
          scope.$watch('infiniteScrollDistance', this.handleInfiniteScrollDistance);
          this.handleInfiniteScrollDistance(scope.infiniteScrollDistance);
          debugMsg("handle-infinite-scroll-distance using", scope.infiniteScrollDistance);
          scope.$watch('infiniteScrollDisabled', handleInfiniteScrollDisabled);
          handleInfiniteScrollDisabled(scope.infiniteScrollDisabled);
          debugMsg("try changing container to $window");
          this.changeContainer($window);
          scope.$watch('infiniteScrollContainer', handleInfiniteScrollContainer);
          this.handleInfiniteScrollContainer(scope.infiniteScrollContainer) || [];
          if (attrs.infiniteScrollParent != null) {
            parent = elem.parent();
            angleParent = this.wrapAngular(parent);
            this.debugMsg("Infinite scroll parent is", angleParent);
            this.changeContainer(angleParent);
          } else {
            this.debugMsg("Infinite scroll parent is window");
          }
          if (attrs.infiniteScrollImmediateCheck != null) {
            this.debugMsg("infinite-scroll-immediate-check", attrs.infiniteScrollImmediatecheck);
            this.config.immediateCheck = scope.$eval(attrs.infiniteScrollImmediatecheck);
          }
          self = this;
          return $timeout(function(){
            self.debugMsg('timeout');
            if (self.immediateCheck) {
              self.debugMsg('immediate check OK - run handler!');
              return self.scrollHandler.handleScroll();
            }
          }, 0);
        }
      };
    }
  ]);
}).call(this);

},{"./scroll-handler":3,"./throttler":4}],3:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var Debugger, ScrollHandler;
  Debugger = require('./debugger');
  ScrollHandler = (function(){
    ScrollHandler.displayName = 'ScrollHandler';
    var prototype = ScrollHandler.prototype, constructor = ScrollHandler;
    importAll$(prototype, arguments[0]);
    function ScrollHandler(scope, config, debug){
      this.scope = scope;
      this.config = config;
      this.container = this.config.container;
      this.elem = this.config.elem;
      this.scrollDistance = this.config.scrollDistance;
      this.scrollEnabled = this.config.scrollEnabled;
      if (debug != null) {
        this.debugOn();
      }
      this.debugLv = parseInt(debug, 10) || 0;
      this;
    }
    prototype.handleScroll = function(){
      infoMsg("remaining", this.remaining());
      infoMsg("scroll-boundary", this.scrollBoundary());
      debug("handle scroll, should:", this.shouldScroll());
      if (this.shouldScroll()) {
        return this.scroll();
      }
    };
    prototype.isWindowContainer = function(){
      return this.container === $window;
    };
    prototype.scroll = function(){
      infoMsg("scroll");
      if (this.scrollEnabled) {
        return this.performScroll();
      } else {
        return this.enableScroll();
      }
    };
    prototype.performScroll = function(){
      infoMsg("perform scroll");
      this.configureScroll();
      return this.scope.infiniteScroll();
    };
    prototype.enableScroll = function(){
      infoMsg("enable scroll", this.config);
      return this.config.enableScroll();
    };
    prototype.configureScroll = function(){
      infoMsg("configure-scroll, window-container:", this.isWindowContainer());
      if (this.isWindowContainer()) {
        return this.configWindowScroll();
      } else {
        return this.configContainerScroll();
      }
    };
    prototype.shouldScroll = function(){
      return this.remaining() <= this.scrollBoundary();
    };
    prototype.scrollBoundary = function(){
      return this.container.height() * this.scrollDistance + 1;
    };
    prototype.remaining = function(){
      return this._remaining || (this._remaining = this.elementBottom - this.containerBottom);
    };
    prototype.configWindowScroll = function(){
      infoMsg("config-window-scroll");
      this.containerBottom = this.container.height() + this.container.scrollTop();
      return this.elementBottom = this.elem.offset().top + this.elem.height();
    };
    prototype.configContainerScroll = function(){
      var containerBottom, elementBottom;
      infoMsg("config-container-scroll");
      containerBottom = this.container.height();
      return elementBottom = this.elem.offset().top - this.container.offset().top + this.elem.height();
    };
    return ScrollHandler;
  }(Debugger));
  module.exports = ScrollHandler;
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);

},{"./debugger":1}],4:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var Debugger, Throttler;
  Debugger = require('./debugger');
  Throttler = (function(){
    Throttler.displayName = 'Throttler';
    var prototype = Throttler.prototype, constructor = Throttler;
    importAll$(prototype, arguments[0]);
    function Throttler($timeout){
      this.$timeout = $timeout;
    }
    prototype.config = function(func, wait){
      this.func = func;
      this.wait = wait;
      return this.throttle;
    };
    prototype.throttle = function(){
      if (this.noTimeRemaining()) {
        return this.reset();
      } else {
        return this.setTimeout();
      }
    };
    prototype.noTimeRemaining = function(){
      return this.remainingTime() <= 0;
    };
    prototype.remainingTime = function(){
      return this.remaining || (this.remaining = wait - (this.now() - this.previous));
    };
    prototype.setTimeout = function(){
      debug("set timeout");
      return this.timeout || (this.timeout = $timeout(later, remaining));
    };
    prototype.reset = function(){
      debug("reset");
      this.clearTimeout(this.timeout);
      this.$timeout.cancel(this.timeout);
      this.timeout = null;
      this.previous = this.now();
      return this.func.call();
    };
    prototype.now = function(){
      return this._now || (this._now = new Date().getTime());
    };
    prototype.timeout = null;
    prototype.previous = 0;
    prototype.later = function(){
      debug("later");
      this.previous = new Date().getTime();
      this.$timeout.cancel(timeout);
      this.timeout = null;
      this.func.call();
      return this.context = null;
    };
    return Throttler;
  }(Debugger));
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);

},{"./debugger":1}]},{},[2])